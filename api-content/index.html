{"posts":[{"title":"GmSSL使用 | 密码算法检验详解","content":" vivi.feng 2021-9-24 工具：GmSSL 环境： win10 VS2019 perl5.26 NASM windows安装gmssl：https://blog.csdn.net/zyhse/article/details/112325129 gmssl github地址：https://github.com/guanzhi/GmSSL 哈希算法检验 SM3，MD5，SHA1，SHA256 (1) 计算哈希命令行： # 进入gmssl后输入： sm3 1.txt md5 1.txt sha1 1.txt sha256 1.txt # 如不进入,在命令前加上gmssl即可 # gmssl所有相关的命令行同理 (2)检测逻辑： HmacMD5 ，HmacSHA1，HmacSHA256 (1)计算哈希命令行： #进入gmssl后输入： dgst -md5 -hmac KEY 1.txt dgst -sha1 -hmac KEY 1.txt dgst -sha256 -hmac KEY 1.txt # KEY为密钥， 1.txt为原文 (2)检测逻辑： 对称密码检验 填充模式： 由于SM4加密算法按照128个位进行分组，所以很大几率会出现最后一个分组不够128位的情况，需要进行填充，填充方式有很多，比如ZeroPadding、PKCS7Padding、PKCS5Padding，不管使用哪种方式，最后每个分组都是128位。GmSSL中可以指定CBC填充方式的，默认采用PKCS7填充，但是你可以选择不填充或者其他的填充方案。具体细节参考evp.h头文件以及手册页。 IV，Initialization Vector 是许多任务作模式中用于将加密随机化的一个位块，由此即使同样的明文被多次加密也会产生不同的密文，避免了较慢的重新产生密钥的过程。初始化向量与密钥相比有不同的安全性需求，因此IV通常无须保密，然而在大多数情况中，不应当在使用同一密钥的情况下两次使用同一个IV。对于CBC和CFB，重用IV会导致泄露明文首个块的某些信息，亦包括两个不同消息中相同的前缀。对于OFB和CTR而言，重用IV会导致完全失去安全性。另外，在CBC模式中，IV在加密时必须是无法预测的； sm4 (1) 加密命令行： #进入gmssl后输入： #加密模式ECB，无需IV参数 enc -e -sms4-ecb -in 1.txt -out sm4ecbenc.txt -K 123456789 -p -nosalt #加密模式CBC, 需要IV参数 enc -e -sms4-cbc -in 1.txt -out sm4cbcenc.txt -K 123456789 -iv=987654321 -p -nosalt (2) 参数信息： (3)检测逻辑： AES (1) 加密命令行： #进入gmssl后输入： # 算法AES,密钥长度192，加密模式ecb,无需iv enc -e -aes-192-ecb -in 1.txt -out aes192ecbenc.txt -K 123456789 -p -nosalt # 算法AES,密钥长度128，加密模式cfb，需要iv enc -e -aes-128-cfb -in 1.txt -out aes128cfbenc.txt -K 123456789 -iv=987654321 -p -nosalt (2) 参数信息： (3)检测逻辑： 公钥加密 公钥加密算法整理逻辑如图： sm2加解密 (1)私钥公钥的生成命令行： #进入gmssl后输入： #手动生成私钥SM2PrivateKey.pem ecparam -genkey -name SM2 -out SM2PrivateKey.pem #通过私钥生成公钥SM2PublicKey.pem ec -in SM2PrivateKey.pem -pubout -out SM2PublicKey.pem (2)加解密命令行： # 通过公钥加密生成密文txt文件 gmssl sm2utl -encrypt -in 1.txt -pubin -inkey SM2PublicKey.pem -out sm2enc.txt # 通过私钥对加密文文件进行解密 gmssl sm2utl -decrypt -in sm2enc.txt -inkey SM2PrivateKey.pem -out sm2dec.txt 注意！！！！ 这里有个BUG，进入gmssl后输入命令加解密过程会出现报错 直接在命令行带上gmssl输入的话就可以运行成功 (3)检测逻辑： RSA加解密 (1)私钥公钥的生成命令行： #手动生成私钥RSAPrivateKey.pem gmssl genrsa -out RSAPrivateKey.pem #通过私钥生成公钥RSAPublicKey.pem gmssl rsa -in RSAPrivateKey.pem -pubout -out RSAPublicKey.pem 注意！！ 生成的密钥默认长度是2048bit，在后面加上1024即可生成1024bit密钥 (2)加解密命令行： # 通过公钥加密生成密文txt文件 gmssl rsautl -encrypt -in 0.txt -inkey RSAPublicKey1024.pem -pubin -out rsaenc.txt # 通过私钥对加密文文件进行解密 gmssl rsautl -decrypt -in rsaenc.txt -inkey RSAPrivateKey1024.pem -out rsadec.txt 注意！！！！ 这里又有个坑，容易出现因为加密内容超长抛出异常，非对称加密的原文长度是有限制的，因为cpu消耗比较高，在实际应用 设计的时候都是用来加密 哈希值 或者 会话密码 之类的。 不注意长度的话，就可以看到如下这种报错了 (3)检测逻辑： 同sm2 数字签名 sm2签名 (1)数字签名生成 # 签名算法中的哈希采用sm3 gmssl dgst -sign SM2PrivateKey.pem -keyform PEM -sm3 -out 0.sign 0.txt (2)数字签名检验 # 签名算法中的哈希采用sm3 gmssl dgst -verify SM2PublicKey.pem -keyform PEM -sm3 -signature 0.sign 0.txt (3)检测逻辑： 为了便于理解数字签名的用法，给出A-B双方通讯A向B发送数据的完整过程图； 数字签名及其验证为红色方框内部分； rsa签名 (1)数字签名生成 # 签名算法中的哈希采用sm3 gmssl dgst -sign RSAPrivateKey1024.pem -keyform PEM -sm3 -out 0rsa.sign 0.txt (2)数字签名检验 # 签名算法中的哈希采用sm3 gmssl dgst -verify RSAPublicKey1024.pem -keyform PEM -sm3 -signature 0rsa.sign 0.txt (3)检测逻辑： sm2检测逻辑 GmSSL用法说明 # GmSSL&gt; help Standard commands asn1parse ca ciphers cms crl crl2pkcs7 dgst dhparam dsa dsaparam ec ecparam enc engine errstr exit gendsa genpkey genrsa gensm9 help list nseq ocsp otp paiutl passwd pkcs12 pkcs7 pkcs8 pkey pkeyparam pkeyutl prime rand rehash req rsa rsautl s_client s_server s_time sdf sess_id skf sm2 sm2utl sm9 sm9param sm9utl smime speed spkac srp ts verify version x509 Message Digest commands (see the `dgst' command for more details) blake2b512 blake2s256 gost md4 md5 mdc2 rmd160 sha1 sha224 sha256 sha384 sha512 sm3 Cipher commands (see the `enc' command for more details) aes-128-cbc aes-128-ecb aes-192-cbc aes-192-ecb aes-256-cbc aes-256-ecb base64 bf bf-cbc bf-cfb bf-ecb bf-ofb camellia-128-cbc camellia-128-ecb camellia-192-cbc camellia-192-ecb camellia-256-cbc camellia-256-ecb cast cast-cbc cast5-cbc cast5-cfb cast5-ecb cast5-ofb des des-cbc des-cfb des-ecb des-ede des-ede-cbc des-ede-cfb des-ede-ofb des-ede3 des-ede3-cbc des-ede3-cfb des-ede3-ofb des-ofb des3 desx idea idea-cbc idea-cfb idea-ecb idea-ofb rc2 rc2-40-cbc rc2-64-cbc rc2-cbc rc2-cfb rc2-ecb rc2-ofb rc4 rc4-40 rc5 rc5-cbc rc5-cfb rc5-ecb rc5-ofb seed seed-cbc seed-cfb seed-ecb seed-ofb sms4 sms4-cbc sms4-cfb sms4-ecb sms4-ofb zuc zuc256 # GmSSL&gt; dgst -help Usage: dgst [options] [file...] file... files to digest (default is stdin) -help Display this summary -c Print the digest with separating colons -r Print the digest in coreutils format -rand val Use file(s) containing random data to seed RNG or an EGD sock -out outfile Output to filename rather than stdout -passin val Input file pass phrase source -sign val Sign digest using private key -verify val Verify a signature using public key -prverify val Verify a signature using private key -signature infile File with signature to verify -keyform format Key file format (PEM or ENGINE) -hex Print as hex dump -binary Print in binary form -d Print debug info -debug Print debug info -fips-fingerprint Compute HMAC with the key used in OpenSSL-FIPS fingerprint -hmac val Create hashed MAC with key -mac val Create MAC (not necessarily HMAC) -sigopt val Signature parameter in n:v form -macopt val MAC algorithm parameters in n:v form or key -* Any supported digest -engine val Use engine e, possibly a hardware device -engine_impl Also use engine given by -engine for digest operations -config val A config file # GmSSL&gt; enc -help Usage: enc [options] Valid options are: -help Display this summary -ciphers List ciphers -in infile Input file #输入文件 -out outfile Output file #输出文件 -pass val Passphrase source -e Encrypt -d Decrypt -p Print the iv/key -P Print the iv/key and exit -v Verbose output -nopad Disable standard block padding -salt Use salt in the KDF (default) -nosalt Do not use salt in the KDF -debug Print debug info -a Base64 encode/decode, depending on encryption flag -base64 Same as option -a -A Used with -[base64|a] to specify base64 buffer as a single line -bufsize val Buffer size -k val Passphrase -kfile infile Read passphrase from file -K val Raw key, in hex -S val Salt, in hex -iv val IV in hex -md val Use specified digest to create a key from the passphrase -none Don't encrypt -* Any supported cipher -engine val Use engine, possibly a hardware device -config val A config file # GmSSL&gt; ecparam -help Usage: ecparam [options] Valid options are: -help Display this summary -inform PEM|DER Input format - default PEM (DER or PEM) -outform PEM|DER Output format - default PEM -in infile Input file - default stdin -out outfile Output file - default stdout -text Print the ec parameters in text form -C Print a 'C' function creating the parameters -check Validate the ec parameters -list_curves Prints a list of all curve 'short names' -no_seed If 'explicit' parameters are chosen do not use the seed -noout Do not print the ec parameter -name val Use the ec parameters with specified 'short name' -conv_form val Specifies the point conversion form -param_enc val Specifies the way the ec parameters are encoded -genkey Generate ec key -rand val Files to use for random number input -engine val Use engine, possibly a hardware device -config val A config file # GmSSL&gt; ec -help Usage: ec [options] Valid options are: -help Display this summary -in val Input file -inform format Input format - DER or PEM -out outfile Output file -outform PEM|DER Output format - DER or PEM -noout Don't print key out -text Print the key -param_out Print the elliptic curve parameters -pubin Expect a public key in input file -pubout Output public key, not private -no_public exclude public key from private key -check check key consistency -passin val Input file pass phrase source -passout val Output file pass phrase source -param_enc val Specifies the way the ec parameters are encoded -conv_form val Specifies the point conversion form -* Any supported cipher -engine val Use engine, possibly a hardware device -config val A config file # GmSSL&gt; sm2utl -help Usage: sm2utl [options] Valid options are: -help Display this summary -in infile Input file - default stdin -out outfile Output file - default stdout -dgst Generate input data digest with Z value -sign Sign input data with private key and public parameters -verify Verify with signer's ID and public parameters -encrypt Encrypt input data with recipient's ID -decrypt Decrypt input data with private key -id val Identity for Z value -sigfile infile Signature file (verify operation only) -inkey val Private key for signing or decryption -pubin Input is a public key -certin Input is a cert with a public key -passin val Input file pass phrase source -keyform PEM|DER|ENGINE Private key format - default PEM -* Any supported digest -engine val Use engine, possibly a hardware device -engine_impl Also use engine given by -engine for crypto operations -config val A config file ","link":"https://Viviairy.github.io/post/gmssl-shi-yong-or-mi-ma-suan-fa-jian-yan-xiang-jie/"},{"title":"自定义: 换上喜欢的主题","content":" 划水混一篇，不过心情确实会变好！！ win10 CMD 打开cmd窗口，点击窗口上沿，打开&lt;属性&gt;，自定义颜色透明度即可，传送门:RGB颜色参考 Microsoft Edge 接下来我们要改掉讨人厌的新建页面，通过界面内右上角&lt;设置&gt;，页面布局改为自定义,将&lt;页面内容&gt;改为&lt;关闭&gt;，即可彻底关掉下面冗余的链接和烦人的广告 VS Code 文件-首选项-颜色主题 notepad++ 在菜单栏点击&lt;设置&gt;-&lt;语言格式格式&gt;更换主题即可 ","link":"https://Viviairy.github.io/post/zi-ding-yi-zhu-ti/"},{"title":"计算机网络重点梳理","content":" 教材用的是《计算机网络自顶向下方法》，本文的话就是简单梳理了一下各层重点的协议，详细可以点这里&gt;传送门：自顶向下计网详细笔记 网络层 IP协议_IPV4 IPv4使用32位2进制位的地址 IPv4通常用点分十进制记法书写，例如192.168.0.1 一个IPv4地址可以分为网络地址和主机地址两部分，其中网络地址可以使用如下形式描述：192.168.0.0/16，其中斜线后的数字表示网络地址部分的长度是16位，即网络地址部分是192.168.0.0。 子网掩码 网掩码是一个应用于TCP/IP网络的32位二进制值，每节8位，必须结合IP地址对应使用。 子网掩码32位都与IP地址32位对应，如果某位是网络地址，则子网掩码为1，否则为0。 (如228.141.32.0/23网络前缀为23 位，掩码是11111111.11111111.11111110.0,即255.255.254.0 ) IP协议_IPV6 为了根本解决IPv4地址耗尽的问题，IPv6应运而生 IPv6的地址长度为128b NAT NAT的主要功能是实现网络地址和IP地址之间的转换。它解决了IPv4地址短缺的问题。 ARP协议 ARP的主要功能是将IP地址转换成物理(MAC)地址 主机的MAC地址长度为48位 传送门：一文详解ARP VPN 虚拟专用网络 路由器选择 AS自治系统内部的路由选择：RIP ,OSRF内部网关协议 AS自治系统之间的路由选择：BGP 外部网关协议 传输层 传送门：一文搞懂TCP与UDP的区别 TCP协议 TCP是面向连接的、提供可靠端到端字节流服务的协议 (无结构流模式) 三次握手，四次挥手： 当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。相当于建立一个传递信息的通道 流量控制，拥塞控制： TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据完完整整从一端传到另一端,注意哦是点对点传输。 一些要求比较高的服务一般使用TCP协议，如FTP、Telnet、SMTP、HTTP、POP3等 UDP协议 是一个简单的面向数据报的运输层协议 (数据报模式) UDP不太可靠，只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。这么多小包,丢一个也没关系... UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。 可以拥有大量Client,支持一对一,一对多 使用UDP协议的常见服务有DNS、SNMP、QQ等 应用层 端口号 端口就好像是门牌，客户端可以通过ip地址找到对应的服务器端，但是服务器端是有很多端口的，为了对端口进行区分，将每个端口进行了编号，这就是端口号 ,每个应用程序对应一个端口号,客户端才能真正的访问到该服务器。 端口号长度是16位。 传送门：TCP/UDP端口列表 RIP协议 Routing Information Protocol,路由信息协议 HTTP协议 -传送门：HTTP协议与HTTPS协议 Telenet协议 Telnet服务的功能是实现远程登陆 它采用TCP的23号端口 SSH协议 SSH服务的功能是实现安全的远程登陆 它采用TCP的22号端口 DNS协议 实现域名到IP地址或IP地址到域名的映射。 根域名-顶级域名-二级域名 使用53号端口 SMTP协议 使用25号端口发送邮件； POP3协议和IMAP协议 POP3使用110号端口接收邮件，IMAP使用143号端口接收邮件。 POP3（即删)，IMAP（可存) -POP3、AMTP、ICMP的区别 FTP协议 文件传送协议，主要功能是实现文件的上传和下载 它的数据通道采用TCP的20号端口，而其控制通道采用TCP的21号端口 TFTP协议 Trivial File Transfer Protocol, 简单文件传输协议 TFTP不具备通常的FTP的许多功能，它只能从文件服务器上获得或写入文件，没有列出目录的功能，也不能对用户进行身份鉴别 TFTP可用于UDP环境；比如当需要将程序或者文件同时向许多机器下载时就往往需要使用到TFTP协议。TFTP代码所占的内存较小，这对于较小的计算机或者某些特殊用途的设备来说是很重要的。 DHCP协议 动态主机配置协议 NTP协议 NTP服务使网络内的所有设备时钟保持一致 使用UDP的123号端口。 Web页面请求过程： DHCP配置主机信息 ARP解析MAC地址 DNS解析域名 HTTP请求响应 链路层 基本问题 封装成帧，透明传输，错误检测(CRC循环冗余检验) 信道分类 广播信道：一对多，信道复用 or **CSMA/CD **载波监听多点接入 / 碰撞检测 点对点信道： PPP 点对点协议 信道复用技 频分复用，时分复用，统计时分复用，波分复用，码分复用 MAC 地址 局域网 以太网：拓扑结构局域网 交换机：学习MAC地址-接口的映射 物理层 通信方式 带通调制 ","link":"https://Viviairy.github.io/post/ji-wang-shu-li/"},{"title":"密码学重点梳理","content":" 密码学是研究编制密码和破译密码技术的科学，包括 密码编码学 (Cryptography) ：研究怎样编码、 如何对消息进行加密 密码分析学(Cryptanalyst)：研究如何对密文进行破译 密码技术相关概念如下： 明文：信息的原始形式 密文：明文经过变换加密后的形式 加密: 由明文——&gt;加密算法——&gt;变成密文的过程 解密: 由密文——&gt;解密算法——&gt;恢复成明文的过程 一、 古典密码 古典密码的基本手段是替代和置换，针对的是字符； 1.1 替换密码 单表代换密码：例如 (Caesar)凯撒密码 结构过于简单，可利用频率分析法进行有效的攻击 多表替换密码：例如 维吉尼亚密码、 Enigma转轮密码机 1.2 置换密码 例如 Hill密码(矩阵加密) 手工阶段和机械阶段使用的密码技术可以称为古典密码技术，古典密码中数据的安全基于加密算法的保密 1949年~1975年，计算机的出现使基于复杂计算的密码成为可能，现代数学方法为加密技术提供了新的工具，信息论为密码学提供了理论基础；主要特点是：(1) 数据的安全基于密钥而不是算法的保密，(2)高次迭代技术和非线性技术的使用，(3) 算法设计需要抵抗各类已知的分析攻击方法 1977年，美国的数据加密标准DES公布，公钥密码使无密钥传输的保密通信成为可能；2001年，美国正式颁布AES为新的国家标准； 近年来，量子密码、DNA密码、化学密码的研究又把我们带入了一个新的密码时代； 二、对称加密 2.1 对称加密体制 对称加密体系也称私钥加密体制、单钥加密体制 特点：加密密钥 = 解密密钥；加密算法 ≈ 解密算法； 优点：速度快，效率高 缺陷：需要安全分配对称密钥 2.2 流密码 对一次一密的模拟，核心是密钥流生成器 经典的密钥流生成器：线性反馈移位寄存器(LFSR) 常见流密码：例如RC4 2.3 分组密码 分组密码设计原则：混淆和扩散 和流密码的区别：对明文的处理方式不同 常见分组密码有： DES(数据加密标准), 3DES ，AES(高级加密标准)，SM4/SMS4(4号国密算法) 2.3.1【 DES 】 DES加密算法与解密算法相同，只是解密使用子密钥与加密子密钥的使用顺序刚好相反 D ES在对明文进行初始置换之后，执行16论的迭代密码。最后经的逆变换得到密文。所谓迭代密码是在密钥控制下多次利用轮函数进行加密变换，以实现扩散和混淆的效果 算法详情： 分组长度：明文、密文64bit 密钥长度：64bit(实际只有56bit) 密钥扩展：输入64位密钥，扩展成都是48bit的轮密钥K1, K2,…,K16 轮变换：每一轮核心运算，输入右分组(32位), 轮密钥(48位)，输出32位；8个S盒，输入6bit，输出4bit 加密：输入明文64位，经过IP置换，对置换后的数据分成左右两半L0与R0，实施16轮轮变换，经过IP-1置换，得到64bit密文 解密与加密几乎一样, 不同之处在于轮密钥的使用顺序 2.3.2 【 3DES 】 分组长度：明文、密文64bit 密钥长度：192bit(实际只有168bit), 使用顺序为(K1, K2, K3) 密文：C=DESk3(DESK2-1(DESK1(M))) 2.3.3 【 AES】 算法名称：Rijndael 分组长度：明/密文128/192/256bit 密钥长度：128/192/256bit 密钥扩展(以128bit为例)：输入密钥128bit，生成11轮128bit的轮密钥 轮变换：对状态矩阵State进行10轮变换，每轮变换包含(1) 字节替换：S盒为8bit输入, 8bit输出；(2) 行移位；(3) 列混合；(4）轮密钥加 加解密：输入明文128bit，作为第0轮的状态矩阵State；经过10轮变换，输出密文128bit 2.3.4【 SM4 国密算法】 前身是SMS4算法 分组长度/密钥长度：128bit 密钥扩展：输入128bit密钥，扩展成32轮32bit的子密钥 加解密：输入明文128位，分成四部分, 实施32次轮变换, 再进行逆序处理得到密文 三、 公钥密码： 3.1 公钥加密体制 也称非对称加密体制、双钥加密体制 特点：加密密钥(公开) ≠ 解密密钥(保密)；加密算法 ≠ 解密算法，公钥密码体系中将密钥一分为二，一个是可公开的密钥PK，另一个则是需要保密的私钥SK ，并且PK≠SK 当多个用户存在时，它可以实现一个用户公钥加密的消息只能被用户私钥解密（可用于公共网络中实现保密通信），或反过来，由一个用户用私钥加密的消息可被多个用户用公钥解读（可用于认证系统中对消息进行数字签） 安全性主要基于数学上的计算困难问题，如大数分解、离散对数、椭圆曲线上离散对数 缺陷：与对称密码相比,效率低 实际应用中常常采用混合加密体制：用 对称加密体制加密明文数据；用公钥加密体制加密对称加密体制中的密钥；解决了对称加密中的密钥分配问题。而由于密钥一般都比较短，用公钥加密也不会多花很长时间 3.1.1【RSA】 安全性基于数论和计算复杂性理论中的大数分解问题，求两个大素数的乘积是计算上容易的，但要分解两个大素数的积求出它的素因子是计算上困难的。 处于安全性考虑，建议使用1024位的模数n，对于重要场合应该使用2048甚至4096位 算法详情： 密钥生成：生成公共参数N，配对的公钥e和私钥d 选取两个n比特的素数p、q，令N = p·q，计算 φ(N)=(p-1)(q-1)，选取与φ(N)互素的正整数e，求正整数d，使得ed ≡ 1 (modφ(N))，公共参数是N, 公钥是e, 私钥是d； 加密： 明文m利用公共参数N和公钥e，加密生成密文c=me(modN) 解密：密文c利用公共参数N和私钥d，解密成明文m'=cd(modN) 3.1.2【Elgamal】 基于离散对数问题 -传送门:Elgamal加密算法详解 3.1.2【ECC】 基于椭圆曲线上离散对数 传送门：ECC椭圆曲线加解密原理详解 3.2 数字签名 消息 — 私钥签名算法 — (消息||签名) — 公钥验证算法 — Yes or No 常见的数字签名体制：RSA数字签名体制、Elgamal数字签名体制、DSA数字签名体制 数字签名：消息 - &gt; (消息, 签名) -&gt; Yes or No 公钥加密：明文 - &gt; 密文 -&gt; 明文 数字签名：签名时用私钥, 验证时用公钥 公钥加密：加密时用公钥, 解密时用私钥 四、 密钥管理 对称密钥管理：多层密钥体系：主密钥 / 次主密钥 / 会话密钥 Diffie-Hellman密钥协商(基于离散对数问题) 公钥数字证书与PKI 公钥基础设施(PKI)：组成部分 数字证书(X.509)：基本格式 核心思想：实现用户身份与其公钥的一一对应 核心机构：认证机构CA 数字证书机制 数字证书 + 公钥加密 数字证书 + 数字签名 五、 Hash函数 Hash函数应用：1. 网站安全登录 ；2. 检测文件篡改 Hash函数基本概念： 定义：任意长度消息-&gt;固定长度的消息摘要 单向性：找原像是困难的 弱抗碰撞性：找第二原像是困难的 强抗碰撞性：找碰撞是困难的 常见Hash函数：MD5、SHA-1 5.1【 MD5 】 消息分组长度：512bit 输出长度：128bit 消息预处理：填充，附加消息长度值 MD5压缩函数：HMD5：{0,1}128+512 —&gt; {0,1}128 MD5主循环：轮数 = 处理后的消息分组数 5.2【 SHA-1 】 消息分组长度：512bit 输出长度：160bit 消息预处理：填充，附加消息长度值 HSHA-1：{0,1}160+512 —&gt; {0,1}160 MD5主循环：轮数 = 处理后的消息分组数 5.3 生日攻击 设Hash函数值为n比特 若取 k = 2n + 1，则肯定能找到碰撞 随机选取不同的消息，则只需要 k ≈ 2n/2，就能以超过50%的概率找到碰撞 2n/2 相比2n小了很多，这种攻击方式称为生日攻击 ","link":"https://Viviairy.github.io/post/mi-ma-xue-chong-dian-shu-li/"}]}