{"posts":[{"title":"自学笔记 | Spring Boot+Vue前后端分离","content":" 昨天和同事们一起聊天，小吴同学吐槽起前东家奇葩，是来了个实习生看完代码连夜离职的程度---因为发现用的还是古老难用的JSP。一直知道前后端分离这个概念，也学过JAVA，但对于背后的一直不太清楚，干脆乘机学一下咯，传送门：4小时学会Spring Boot +Vue前后端分离 前后端分离就是将一个应用的前端代码和后端代码分开写，为什么要这样做? 如果不使用前后端分离的方式，会有哪些问题? 传统的Java Web开发中，前端使用JSP开发, JSP 不是由后端开发者来独立完成的。 前端--》HTML静态页面--&gt;后端- JSP 这种开发方式效率极低，可以使用前后端分离的方式进行开发，就可以完美地解决这一-问题。 前端只需要独立编写客户端代码，后端也只需要独立编写服务端代码提供数据接口即可。 前端通过Ajax请求来访问后端的数据接口，将Model展示到View中即可。 前后端开发者只需要提前约定好接口文档(URL、 参数、数据类型..)，然后分别独立开发即可，前端 可以造假数据进行测试，完全不需要依赖于后端，最后完成前后端集成即可，真正实现了前后端应用的 解耦合，极大地提升了开发效率。 单体--》前端应用+后端应用 前端应用:负责数据展示和用户交互。 后端应用:负责提供数据处理接口。 前端HTML --》Ajax --&gt; RESTful 后端数据接口。 传统的单体应用 前后端分离的结构 ","link":"https://Viviairy.github.io/b-zhan-ke-cheng-or-spring-bootvue-qian-hou-duan-fen-chi/"},{"title":"踩坑 | 理解字符编码与乱码","content":" 最近踩到的坑是解析文件到输入框出现字符乱码问题，发现自己一直忽视了字符编码格式的问题。理解了一些，但还是没有搞明白，之后在看吧... 首先明确一点，计算机屏幕显示和计算机内部存储是两码事，不管是文本还是图片视频，计算机存储里面只有0、1 。为了便于组合划分，引入了字节的概念，1个字节(byte)8个位(bit)，可以表示2^8即256个数字。 00 编码初衷 之所以需要编码，就是因为计算机和人类语言不通，计算机只认得的二进制对人类来说，阅读难度太大，人类更擅长识别文字，双方都没办法妥协，为了便于和机器沟通，我们需要就需要翻译： 首先，需要人为地确定一套翻译的规则，这套规则里面需要明确人能认识的字符和计算机认识的二进制之间要怎么对应。所谓编码，就是从文字映射到0、1的过程；解码，就是反过来从0、1映射到文字的过程。 01 字符编码类型 这对于使用英语或者某些西欧洲语言的国家来说已经很够用了，最初诞生的ASCII ((American Standard Code for Information Interchange): 美国信息交换标准代码）甚至只有128个字符。 用来表示其他语言，尤其是像中、日和韩的象形文字，有成千上万独立的字符，很显然就不能满足需求了。每个国家都研制的编码后期很难统一，那干脆就把将世界当成一个整体，把所有的文字统一编号，unicode编码应运而生。 还有GB2312、GBK、GB18030、UTF-8。 02 乱码现象 编码方式多了就容易出现乱码。再强调一遍，乱码只是翻译显示的问题，也就是说，只有人才知道乱码﹐计算机只认识0、1在它看来这并不是问题。 不同编码之间真正的区别在于存储结构。同样的文本字符，经过不同的编码，会翻译成不同的字节流，在存储结构上是不一样的。反过来，相同的字节流经过不同的方式解码会有不同的结果展示，但是其内存上结构上并没有改变。 03乱码的原因 出现乱码的原因就是文本字符编码过程与字节流解码过程使用了不同的编码格式，这个往往归咎于解码格式选择错误。如果我的字符是用utf-8编码，你用GBK解码那肯定出问题。因为文字按照utf-8的编码规则编成的0、1，按照GBK的规则解码回来的文字并不是原来 的文字，这时候就会出现乱码了。这种问题会出现在文件读写、网络编码传输、数据库存取上。只要牵涉到字符都有可能出现乱码，因为只要有字符就会有解码过程。 还有一种 情况就是文件压根不是文本文件，也就是说根本就没有经过编码这个过程，那你去解码当然乱码了。比如64，你如果看做文本字符就是6和4两个字符，可以对应 编码格式进行编码。如果看做是数字64，那对应的存储结构是0100 0000，就没有编码过程也就不需要去解码。 参考链接：https://blog.csdn.net/Alexshi5/article/details/79513018 ","link":"https://Viviairy.github.io/zi-fu-bian-ma/"},{"title":"踩坑 | 解决VMware Ubuntu20连不上网","content":" 用虚拟机最讨厌的事情莫过于突然连不上网，晚上换了个wifi忽然又网络连接失败了，搞了一个多小时，记录一下，此方法亲测有效，缺点就是麻烦不能一劳永逸 步骤1：Vmware&lt;编辑&gt;-&lt;虚拟网络编辑器&gt; 1： 还原默认设置 2： 选择桥接模式 3： 桥接到本机正在使用的物理网卡 步骤2：虚拟机&lt;设置&gt;-&lt;网络适配器&gt; 1: 选中设置成桥接模式 2: 勾选复制物理网络连接 步骤3：给虚拟机手动分配ipv4 1：本机cmd输入ipconfig /all查看主机ipv4信息 2：在Ubuntu中找到设置-网络，设置手动配置ip - 地址前三段和本机一致，最后一位任意 - 子网掩码、网关、DNS均和本机一致 Q：什么是桥接模式（bridged） 在bridged模式下，VMWare虚拟出来的操作系统就像是局域网中单独存在的“物理机”一样 ，虚拟机和宿主机在网络中处于同等地位，它可以访问局域网内任何一台机器。 需要手工为虚拟机配置IP地址（和宿主机器处于同一网段）、子网掩码、网关、DNS。来实现和宿主机进行通信以及访问互联网。 如果想利用VMWare在局域网内新建一个虚拟服务器，为局域网用户提供网络服务，就应该选择桥接模式。 Q：安装了虚拟机之后会多出两个虚拟网卡他们的主要作用： VMnet0：用于虚拟桥接网络下的虚拟交换机（未显示） VMnet1：用于虚拟Host-Only网络下的虚拟交换机 VMnet8：用于虚拟NAT网络下的虚拟交换机 参考链接：https://blog.csdn.net/weixin_43434136/article/details/116759692 ","link":"https://Viviairy.github.io/jie-jue-vmware-ubuntu20-lian-bu-shang-wang/"},{"title":"自学笔记 | Shell脚本快速入门","content":" 脚本，就是把重复枯燥无聊的工作自动化写的一个程序，偷懒人士太喜欢这个概念啦！ shell视频教程 01 什么是shell shell是一个用C语言编写的程序，便利用户和linux内核的沟通，是一种指令语言，解释性语言 用户：给内核下指令 内核：接收指令，管理硬件、驱动硬件干活 问题是用户和内核之间语言不通，内核只认识二进制语言 shell：就是个翻译 02 一个脚本的组成 (1) 脚本信息 #Author: VIVI #Create Time:2021-10-14 22:45 #Version:1.0 #Script Description: for test (2) 解释环境 用于定义脚本的执行环境，#! 是特例，用来找到解释器 #! /usr/bin/bash #! /usr/bin/env bash|python| perl (3) 脚本正文 组成就是代码和注释，为了避免出错不要有中文 03 shell的运行 方法1：直接执行 #前提是有rwx权限，那么才可以直接执行 ./路径/文件名.sh 方法2：解释器运行 chomd 644 文件名.sh #首先给定文件权限，rw-r-r ll 文件名.sh #可查看文件的权限 bash 文件名.sh #执行方法1 sh 文件名.sh #执行方法1 04 基础概念 管道 重定向 指令 &gt; 文件名 #将内容写入文件 指令 &gt;&gt; 文件名 #追加内容写入文件 某条指令 &amp;&gt;/dev/null #重定向指令输出到无底洞，即不显示输出 #以自动为磁盘挂载分区为例子 fdisk /dev/loop10&lt; EOF #开始 X #系列输入值1 X #系列输入值2 X #系列输入值3 EOF #结束 数学运算 echo $((里面输入公式)) #最简单的 expr 10 + 10 #加，需要空格分割，加、减、除法同理 expr 20 \\* 2 #乘，*为特殊字符，反斜杠（\\）转义 expr \\( 10 + 10 \\) \\* 2 + 100 #四则运算 let sum=10+10 #结果存在sum中，不显示 echo $sum #回显sum值 但是上面的哪些只支持正整数计算麻烦有鸡肋，建议直接用bc命令进入计算器 echo输出 #echo调用工具 #在echo中执行命令的话只要用写在``里面就可以 #step1，第一个echo用来填充运算结果 echo &quot;scale=2;100/3&quot;|bc #step2，第二个用来补充说明输出 echo &quot;100除以3约等于 `echo &quot;scale=2;100/3&quot;|bc` %&quot; exit NUM #取值0-255,可用于报错 echo $? #即可查看指令执行状况 格式化输出 echo -n #输出不换行 echo -e #输出转义字符 \\n #换行 \\t #制表符 \\a #鸣响 \\b #删除前一个字符 倒计时的例子 #!/usr/bin/bash for time in ‘seq 9 -1 0’;do echo -e &quot;-b$time&quot; sleep 1 done echo read输入 echo -n &quot;输入你的密码:&quot; read pw #键盘输入值存入pw中 echo &quot;你的密码是：$pw&quot; #即可调用打印密码值 获取用户输入可以直接写成一句 read -p &quot;输入密码:&quot; pw #read命令选项 -p #打印信息 -s #不回显 -t60 #限制时间60s -n6 #限制字符个数6位 ","link":"https://Viviairy.github.io/ru-he-xie-hao-yi-ge-shell-jiao-ben/"},{"title":"开源工具 | 基于GmSSL的密码算法检验","content":" 工具：GmSSL 环境： win10 VS2019 perl5.26 NASM windows安装gmssl：https://blog.csdn.net/zyhse/article/details/112325129 gmssl github地址：https://github.com/guanzhi/GmSSL 1 哈希算法检验 1.1 SM3，MD5，SHA1，SHA256 (1) 计算哈希命令行： # 进入gmssl后输入： sm3 1.txt md5 1.txt sha1 1.txt sha256 1.txt # 如不进入,在命令前加上gmssl即可 # gmssl所有相关的命令行同理 (2)检测逻辑： 1.2 HmacMD5 ，HmacSHA1，HmacSHA256 (1)计算哈希命令行： #进入gmssl后输入： dgst -md5 -hmac KEY 1.txt dgst -sha1 -hmac KEY 1.txt dgst -sha256 -hmac KEY 1.txt # KEY为密钥， 1.txt为原文 (2)检测逻辑： 2 对称密码检验 填充模式： 由于SM4加密算法按照128个位进行分组，所以很大几率会出现最后一个分组不够128位的情况，需要进行填充，填充方式有很多，比如ZeroPadding、PKCS7Padding、PKCS5Padding，不管使用哪种方式，最后每个分组都是128位。GmSSL中可以指定CBC填充方式的，默认采用PKCS7填充，但是你可以选择不填充或者其他的填充方案。具体细节参考evp.h头文件以及手册页。 IV，Initialization Vector 是许多任务作模式中用于将加密随机化的一个位块，由此即使同样的明文被多次加密也会产生不同的密文，避免了较慢的重新产生密钥的过程。初始化向量与密钥相比有不同的安全性需求，因此IV通常无须保密，然而在大多数情况中，不应当在使用同一密钥的情况下两次使用同一个IV。对于CBC和CFB，重用IV会导致泄露明文首个块的某些信息，亦包括两个不同消息中相同的前缀。对于OFB和CTR而言，重用IV会导致完全失去安全性。另外，在CBC模式中，IV在加密时必须是无法预测的； 2.1 sm4 (1) 加密命令行： #进入gmssl后输入： #加密模式ECB，无需IV参数 enc -e -sms4-ecb -in 1.txt -out sm4ecbenc.txt -K 123456789 -p -nosalt #加密模式CBC, 需要IV参数 enc -e -sms4-cbc -in 1.txt -out sm4cbcenc.txt -K 123456789 -iv=987654321 -p -nosalt (2)检测逻辑： 2.2 AES (1) 加密命令行： #进入gmssl后输入： # 算法AES,密钥长度192，加密模式ecb,无需iv enc -e -aes-192-ecb -in 1.txt -out aes192ecbenc.txt -K 123456789 -p -nosalt # 算法AES,密钥长度128，加密模式cfb，需要iv enc -e -aes-128-cfb -in 1.txt -out aes128cfbenc.txt -K 123456789 -iv=987654321 -p -nosalt (2)检测逻辑： 3 公钥加密 公钥加密算法整理逻辑如图： 3.1 sm2加解密 (1)私钥公钥的生成命令行： #进入gmssl后输入： #手动生成私钥SM2PrivateKey.pem ecparam -genkey -name SM2 -out SM2PrivateKey.pem #通过私钥生成公钥SM2PublicKey.pem ec -in SM2PrivateKey.pem -pubout -out SM2PublicKey.pem (2)加解密命令行： # 通过公钥加密生成密文txt文件 gmssl sm2utl -encrypt -in 1.txt -pubin -inkey SM2PublicKey.pem -out sm2enc.txt # 通过私钥对加密文文件进行解密 gmssl sm2utl -decrypt -in sm2enc.txt -inkey SM2PrivateKey.pem -out sm2dec.txt 注意！！！！ 这里有个BUG，进入gmssl后输入命令加解密过程会出现报错 直接在命令行带上gmssl输入的话就可以运行成功 (3)检测逻辑： 3.2 RSA加解密 (1)私钥公钥的生成命令行： #手动生成私钥RSAPrivateKey.pem gmssl genrsa -out RSAPrivateKey.pem #通过私钥生成公钥RSAPublicKey.pem gmssl rsa -in RSAPrivateKey.pem -pubout -out RSAPublicKey.pem 注意！！ 生成的密钥默认长度是2048bit，在后面加上1024即可生成1024bit密钥 (2)加解密命令行： # 通过公钥加密生成密文txt文件 gmssl rsautl -encrypt -in 0.txt -inkey RSAPublicKey1024.pem -pubin -out rsaenc.txt # 通过私钥对加密文文件进行解密 gmssl rsautl -decrypt -in rsaenc.txt -inkey RSAPrivateKey1024.pem -out rsadec.txt 注意！！！！ 这里又有个坑，容易出现因为加密内容超长抛出异常，非对称加密的原文长度是有限制的，因为cpu消耗比较高，在实际应用 设计的时候都是用来加密 哈希值 或者 会话密码 之类的。 不注意长度的话，就可以看到报错了 (3)检测逻辑： 同sm2 4 数字签名验签 4.1 sm2签名 (1)数字签名生成 # 签名算法中的哈希采用sm3 gmssl dgst -sign SM2PrivateKey.pem -keyform PEM -sm3 -out 0.sign 0.txt (2)数字签名检验 # 签名算法中的哈希采用sm3 gmssl dgst -verify SM2PublicKey.pem -keyform PEM -sm3 -signature 0.sign 0.txt (3)检测逻辑： 为了便于理解数字签名的用法，给出A-B双方通讯A向B发送数据的完整过程图； 数字签名及其验证为红色方框内部分 4.2 rsa签名 (1)数字签名生成 # 签名算法中的哈希采用sm3 gmssl dgst -sign RSAPrivateKey1024.pem -keyform PEM -sm3 -out 0rsa.sign 0.txt (2)数字签名检验 # 签名算法中的哈希采用sm3 gmssl dgst -verify RSAPublicKey1024.pem -keyform PEM -sm3 -signature 0rsa.sign 0.txt (3)检测逻辑： sm2检测逻辑 GmSSL用法说明 # GmSSL&gt; help Standard commands asn1parse ca ciphers cms crl crl2pkcs7 dgst dhparam dsa dsaparam ec ecparam enc engine errstr exit gendsa genpkey genrsa gensm9 help list nseq ocsp otp paiutl passwd pkcs12 pkcs7 pkcs8 pkey pkeyparam pkeyutl prime rand rehash req rsa rsautl s_client s_server s_time sdf sess_id skf sm2 sm2utl sm9 sm9param sm9utl smime speed spkac srp ts verify version x509 Message Digest commands (see the `dgst' command for more details) blake2b512 blake2s256 gost md4 md5 mdc2 rmd160 sha1 sha224 sha256 sha384 sha512 sm3 Cipher commands (see the `enc' command for more details) aes-128-cbc aes-128-ecb aes-192-cbc aes-192-ecb aes-256-cbc aes-256-ecb base64 bf bf-cbc bf-cfb bf-ecb bf-ofb camellia-128-cbc camellia-128-ecb camellia-192-cbc camellia-192-ecb camellia-256-cbc camellia-256-ecb cast cast-cbc cast5-cbc cast5-cfb cast5-ecb cast5-ofb des des-cbc des-cfb des-ecb des-ede des-ede-cbc des-ede-cfb des-ede-ofb des-ede3 des-ede3-cbc des-ede3-cfb des-ede3-ofb des-ofb des3 desx idea idea-cbc idea-cfb idea-ecb idea-ofb rc2 rc2-40-cbc rc2-64-cbc rc2-cbc rc2-cfb rc2-ecb rc2-ofb rc4 rc4-40 rc5 rc5-cbc rc5-cfb rc5-ecb rc5-ofb seed seed-cbc seed-cfb seed-ecb seed-ofb sms4 sms4-cbc sms4-cfb sms4-ecb sms4-ofb zuc zuc256 # GmSSL&gt; dgst -help Usage: dgst [options] [file...] file... files to digest (default is stdin) -help Display this summary -c Print the digest with separating colons -r Print the digest in coreutils format -rand val Use file(s) containing random data to seed RNG or an EGD sock -out outfile Output to filename rather than stdout -passin val Input file pass phrase source -sign val Sign digest using private key -verify val Verify a signature using public key -prverify val Verify a signature using private key -signature infile File with signature to verify -keyform format Key file format (PEM or ENGINE) -hex Print as hex dump -binary Print in binary form -d Print debug info -debug Print debug info -fips-fingerprint Compute HMAC with the key used in OpenSSL-FIPS fingerprint -hmac val Create hashed MAC with key -mac val Create MAC (not necessarily HMAC) -sigopt val Signature parameter in n:v form -macopt val MAC algorithm parameters in n:v form or key -* Any supported digest -engine val Use engine e, possibly a hardware device -engine_impl Also use engine given by -engine for digest operations -config val A config file # GmSSL&gt; enc -help Usage: enc [options] Valid options are: -help Display this summary -ciphers List ciphers -in infile Input file #输入文件 -out outfile Output file #输出文件 -pass val Passphrase source -e Encrypt -d Decrypt -p Print the iv/key -P Print the iv/key and exit -v Verbose output -nopad Disable standard block padding -salt Use salt in the KDF (default) -nosalt Do not use salt in the KDF -debug Print debug info -a Base64 encode/decode, depending on encryption flag -base64 Same as option -a -A Used with -[base64|a] to specify base64 buffer as a single line -bufsize val Buffer size -k val Passphrase -kfile infile Read passphrase from file -K val Raw key, in hex -S val Salt, in hex -iv val IV in hex -md val Use specified digest to create a key from the passphrase -none Don't encrypt -* Any supported cipher -engine val Use engine, possibly a hardware device -config val A config file # GmSSL&gt; ecparam -help Usage: ecparam [options] Valid options are: -help Display this summary -inform PEM|DER Input format - default PEM (DER or PEM) -outform PEM|DER Output format - default PEM -in infile Input file - default stdin -out outfile Output file - default stdout -text Print the ec parameters in text form -C Print a 'C' function creating the parameters -check Validate the ec parameters -list_curves Prints a list of all curve 'short names' -no_seed If 'explicit' parameters are chosen do not use the seed -noout Do not print the ec parameter -name val Use the ec parameters with specified 'short name' -conv_form val Specifies the point conversion form -param_enc val Specifies the way the ec parameters are encoded -genkey Generate ec key -rand val Files to use for random number input -engine val Use engine, possibly a hardware device -config val A config file # GmSSL&gt; ec -help Usage: ec [options] Valid options are: -help Display this summary -in val Input file -inform format Input format - DER or PEM -out outfile Output file -outform PEM|DER Output format - DER or PEM -noout Don't print key out -text Print the key -param_out Print the elliptic curve parameters -pubin Expect a public key in input file -pubout Output public key, not private -no_public exclude public key from private key -check check key consistency -passin val Input file pass phrase source -passout val Output file pass phrase source -param_enc val Specifies the way the ec parameters are encoded -conv_form val Specifies the point conversion form -* Any supported cipher -engine val Use engine, possibly a hardware device -config val A config file # GmSSL&gt; sm2utl -help Usage: sm2utl [options] Valid options are: -help Display this summary -in infile Input file - default stdin -out outfile Output file - default stdout -dgst Generate input data digest with Z value -sign Sign input data with private key and public parameters -verify Verify with signer's ID and public parameters -encrypt Encrypt input data with recipient's ID -decrypt Decrypt input data with private key -id val Identity for Z value -sigfile infile Signature file (verify operation only) -inkey val Private key for signing or decryption -pubin Input is a public key -certin Input is a cert with a public key -passin val Input file pass phrase source -keyform PEM|DER|ENGINE Private key format - default PEM -* Any supported digest -engine val Use engine, possibly a hardware device -engine_impl Also use engine given by -engine for crypto operations -config val A config file ","link":"https://Viviairy.github.io/gmssl-shi-yong-or-mi-ma-suan-fa-jian-yan-xiang-jie/"},{"title":"划水 | 换上喜欢的主题","content":" 划水混一篇，不过心情确实会变好！！ win10 CMD 打开cmd窗口，点击窗口上沿，打开&lt;属性&gt;，自定义颜色透明度即可，传送门:RGB颜色参考 Microsoft Edge 接下来我们要改掉讨人厌的新建页面，通过界面内右上角&lt;设置&gt;，页面布局改为自定义,将&lt;页面内容&gt;改为&lt;关闭&gt;，即可彻底关掉下面冗余的链接和烦人的广告 VS Code 文件-首选项-颜色主题 notepad++ 在菜单栏点击&lt;设置&gt;-&lt;语言格式格式&gt;更换主题即可 ","link":"https://Viviairy.github.io/zi-ding-yi-zhu-ti/"},{"title":"自学笔记 | 整理常用linux指令","content":"linux入门 最近在研究linux，网上资源太多了，我挑出来一个目前为止我看到的最干货的教程和一个很好用的搜索工具，打算跟着这个系统学习一下linux系统，在这里记录一下。 &gt;- 鸟哥的linux私房菜 &gt;感觉系统学习linux这个就够了，但是台湾翻译的问题有些表达会不太一样 &gt;- Linux命令在线搜索工具 &gt;这个工具真的好用，能够搜索到Linux常见命令，以及语法，说明和一些实例，工具来自一个github开源项目，这个项目readme文档里面有超级多相关的学习资源。 Linux 一般作为服务器使用，服务器一般放在机房，这时我们就需要远程登录到Linux服务器来管理维护系统。Linux 系统中是通过 ssh 服务实现的远程登录功能，默认 ssh 服务端口号为 22。可以在自己的电脑上通过XShell客户端远程控制。 用XShell远程连接到linux系统，只能通过一个命令行界面控制，这就需要熟练使用linux基本的命令了 便捷操作 cd ~ #回到根目录 cd - #回到上次所在目录 !! #查看上次输入的指令以及结果 ！p #查询最近一次以p开头的指令信息 history #查看所有历史指令 cat /etc/passwd #查看所有系统用户 cat /etc/passwd | grep &quot;fvivi&quot; #检索条件 echo xxx #输出xxx echo $? #查询上条指令是否执行成功，0成功 ifconfig -a #查询ip信息 文件操作 vim 文件名 #创建、编辑文件 gedit 文件名 #更好用的创建、编辑文件 rm 文件名 #删除文件 cat 文件名 #查看文件内容 wc 文件名 #查询文件基本信息 chomd 644 文件名 #change mode首先给定文件权限，rw-r-r ll 文件名 #可查看文件的权限 ls -l 文件名 #查询是否存在某文件 暂且就是以上，持续更新中 (●'◡'●)/ ","link":"https://Viviairy.github.io/linux-zhi-ing/"},{"title":"实验 | Python绘制Wireshark报文三次握手","content":" python网络编程课的一个小作业 题目说明： 打开Wireshark，在联网的网卡上开始抓包过程，再用浏览器打开链接，关闭网页并结束抓包过程，然后将抓包内容保存为pcapng格式的文件。 对上述pcapng文件，使用Scapy库或其他解析库，获取到tcp三报文连接或tcp四报文释放的信息，获取到相关信息后，再用Matplot库绘制三报文连接的过程。 所选Python库介绍 Scapy: Scrapy 是用 Python 实现的一个为了爬取网站数据、提取结构性数据而编写的应用框架。 Matplotlib Matplotlib 是一个 Python 的 2D绘图库 程序源代码 from scapy.all import * import matplotlib.pyplot as plt pcap_path = &quot;D:/tcp2.pcapng&quot; packets = rdpcap(pcap_path) # 读取数据包 # 设置figure大小 plt.figure(figsize=(10,8)) # 隐藏边框 plt.gca().spines[&quot;top&quot;].set_alpha(.0) plt.gca().spines[&quot;bottom&quot;].set_alpha(.0) plt.gca().spines[&quot;right&quot;].set_alpha(.0) plt.gca().spines[&quot;left&quot;].set_alpha(.0) # 添加标题 plt.title(&quot;TCP connection&quot;, fontsize=18) # 横纵坐标范围 plt.axis([0,10,0,10]) # 添加横坐标标签 plt.xticks([1,9],[packets[0][&quot;IP&quot;].src, packets[0][&quot;IP&quot;].dst]) # 隐藏纵坐标标签 plt.yticks([]) # 两条竖线 plt.vlines(x=1, ymin=0, ymax=10, linestyles='dotted') plt.vlines(x=9, ymin=0, ymax=10, linestyles='dotted') # 添加文字 plt.text(1, 10, 'Client', horizontalalignment='center', fontsize=15) plt.text(9, 10, 'Server', horizontalalignment='center', fontsize=15) client_ip = packets[0][&quot;IP&quot;].src # 对每一个数据包的数据进行处理 for i in range(len(packets)): if packets[i][&quot;IP&quot;].src == client_ip: # 如果是从客户端发往服务器 p1=[1,9-2*i] p2=[9,9-2*i-1] else: # 如果是从服务器发往客户端 p1=[9,9-2*i] p2=[1,9-2*i-1] # 画一条带箭头的线 plt.arrow(p1[0],p1[1],p2[0]-p1[0],p2[1]-p1[1], length_includes_head=True, # 长度包含箭头部分 head_width=0.2,head_length=0.2,color='purple') # 箭头的长宽和颜色 # 添加数据信息 message = 'sport='+str(packets[i][&quot;TCP&quot;].sport)+','+'dport='+str(packets[i][&quot;TCP&quot;].dport)+','+'seq='+str(packets[i][&quot;TCP&quot;].seq)+','+'ack='+str(packets[i][&quot;TCP&quot;].ack)+','+'flags='+str(packets[i][&quot;TCP&quot;].flags) plt.text(5, p1[1], message, horizontalalignment='center', fontsize=10) plt.show() 程序测试方法及测试结果记录 测试方法 首先查询本机ip以及访问的目标网址对应的ip 根据ip过滤数据包，再筛选出tcp三次握手的报文如下，另存文件为tcp. pcapng 下图中前三个数据包即为TCP建立连接三次握手过程，第四个包才是http的，http使用TCP建立连接成功。 下面逐步分析三次握手过程 第一次握手：客户端向服务器发送连接请求包，标志位SYN（同步序号）置为1，序号为X=0 第二次握手：服务器收到客户端发过来报文，由SYN=1知道客户端要求建立联机。向客户端发送一个SYN和ACK都置为1的TCP报文，设置初始序号Y=0，将确认序号设置为客户的序列号加1，即X+1 = 0+1=1 第三次握手： 客户端收到服务器发来的包后检查确认序号是否正确，即第一次发送的序号加1（X+1=1）。以及标志位ACK是否为1。若正确，客户端再次发送确认包，ACK标志位为1，SYN标志位为0。确认序号(Acknowledgement Number)=Y+1=0+1=1，发送序号为X+1=1。服务器收到后确认序号值与ACK=1则连接建立成功，可以传送数据了。 测试流程 运行代码可以看见三次握手建立连接的过程 ","link":"https://Viviairy.github.io/wiresharkpython-hui-zhi-san-ci-wo-shou/"},{"title":"理论基础 | 计算机网络重点梳理","content":" 教材用的是《计算机网络自顶向下方法》，本文的话就是简单梳理了一下各层重点的协议，详细可以点这里&gt;传送门：自顶向下计网详细笔记 网络层 IP协议_IPV4 IPv4使用32位2进制位的地址 IPv4通常用点分十进制记法书写，例如192.168.0.1 一个IPv4地址可以分为网络地址和主机地址两部分，其中网络地址可以使用如下形式描述：192.168.0.0/16，其中斜线后的数字表示网络地址部分的长度是16位，即网络地址部分是192.168.0.0。 子网掩码 网掩码是一个应用于TCP/IP网络的32位二进制值，每节8位，必须结合IP地址对应使用。 子网掩码32位都与IP地址32位对应，如果某位是网络地址，则子网掩码为1，否则为0。 (如228.141.32.0/23网络前缀为23 位，掩码是11111111.11111111.11111110.0,即255.255.254.0 ) IP协议_IPV6 为了根本解决IPv4地址耗尽的问题，IPv6应运而生 IPv6的地址长度为128b NAT NAT的主要功能是实现网络地址和IP地址之间的转换。它解决了IPv4地址短缺的问题。 ARP协议 ARP的主要功能是将IP地址转换成物理(MAC)地址 主机的MAC地址长度为48位 传送门：一文详解ARP VPN 虚拟专用网络 路由器选择 AS自治系统内部的路由选择：RIP ,OSRF内部网关协议 AS自治系统之间的路由选择：BGP 外部网关协议 传输层 传送门：一文搞懂TCP与UDP的区别 TCP协议 TCP是面向连接的、提供可靠端到端字节流服务的协议 (无结构流模式) 三次握手，四次挥手： 当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。相当于建立一个传递信息的通道 流量控制，拥塞控制： TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据完完整整从一端传到另一端,注意哦是点对点传输。 一些要求比较高的服务一般使用TCP协议，如FTP、Telnet、SMTP、HTTP、POP3等 UDP协议 是一个简单的面向数据报的运输层协议 (数据报模式) UDP不太可靠，只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。这么多小包,丢一个也没关系... UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。 可以拥有大量Client,支持一对一,一对多 使用UDP协议的常见服务有DNS、SNMP、QQ等 应用层 端口号 端口就好像是门牌，客户端可以通过ip地址找到对应的服务器端，但是服务器端是有很多端口的，为了对端口进行区分，将每个端口进行了编号，这就是端口号 ,每个应用程序对应一个端口号,客户端才能真正的访问到该服务器。 端口号长度是16位。 传送门：TCP/UDP端口列表 RIP协议 Routing Information Protocol,路由信息协议 HTTP协议 -传送门：HTTP协议与HTTPS协议 Telenet协议 Telnet服务的功能是实现远程登陆 它采用TCP的23号端口 SSH协议 SSH服务的功能是实现安全的远程登陆 它采用TCP的22号端口 DNS协议 实现域名到IP地址或IP地址到域名的映射。 根域名-顶级域名-二级域名 使用53号端口 SMTP协议 使用25号端口发送邮件； POP3协议和IMAP协议 POP3使用110号端口接收邮件，IMAP使用143号端口接收邮件。 POP3（即删)，IMAP（可存) -POP3、AMTP、ICMP的区别 FTP协议 文件传送协议，主要功能是实现文件的上传和下载 它的数据通道采用TCP的20号端口，而其控制通道采用TCP的21号端口 TFTP协议 Trivial File Transfer Protocol, 简单文件传输协议 TFTP不具备通常的FTP的许多功能，它只能从文件服务器上获得或写入文件，没有列出目录的功能，也不能对用户进行身份鉴别 TFTP可用于UDP环境；比如当需要将程序或者文件同时向许多机器下载时就往往需要使用到TFTP协议。TFTP代码所占的内存较小，这对于较小的计算机或者某些特殊用途的设备来说是很重要的。 DHCP协议 动态主机配置协议 NTP协议 NTP服务使网络内的所有设备时钟保持一致 使用UDP的123号端口。 Web页面请求过程： DHCP配置主机信息 ARP解析MAC地址 DNS解析域名 HTTP请求响应 链路层 基本问题 封装成帧，透明传输，错误检测(CRC循环冗余检验) 信道分类 广播信道：一对多，信道复用 or **CSMA/CD **载波监听多点接入 / 碰撞检测 点对点信道： PPP 点对点协议 信道复用技 频分复用，时分复用，统计时分复用，波分复用，码分复用 MAC 地址 局域网 以太网：拓扑结构局域网 交换机：学习MAC地址-接口的映射 物理层 通信方式 带通调制 ","link":"https://Viviairy.github.io/ji-wang-shu-li/"},{"title":"理论基础 | 数据库原理概述","content":"数据库概述 本来是整理给小孟复习用的，整理半天发现整理了个寂寞，这篇博客将会带你系统地(粗略地)梳理一下数据库系统的基础知识，博客是按照高等教育出版社出版的《数据库系统概述（第5版）》这本教材来的。 开始之前现先来理解一下最最基本的四个概念 数据（Date） ​ - 数据是描述事物的记录。数据和语义是不可分的，也就是说，给出数据的时候需要解释数据的意义，比如说小明某数据18，那这个18是代表年龄还是尺寸这得讲清楚。数据的形式可以是多种多样的，除了文字、数字还有图形、音频、视频等等，它们都可以经过数字化后存入计算机 数据库（DateBase , DB） ​ - 即为用于存储数据的仓库，是长期存储在计算机内、有组织、可共享的大量数据集合（这个也是数据库的基本特征） 数据库管理系统（DateBase Management System,DBMS） ​ - 位于用户和操作系统之间的一层数据管理软件。耳熟能详的有MySQL，SQL Server，Oracle等。 数据库系统（DateBaseSystem,DBS） ​ - 就是一个使用、管理、存储数据的系统，包括数据库、硬件、软件、人员 ​ - 这里还涉及到数据库系统的三级模式结构和二级映射 构建数据库其实就是一个建模的过程。 1）首先对现实世界进行分析，将客观对象抽象为某一信息结构（即概念模型） 2）再把概念模型转换到计算机上某一数据库管理系统支持的数据模型。 拿一个学校抽象出学生系统来，第一步，划分群体学生，第二步，建模 概念模型 所谓的概念模型就是从现实世界抽象出来的信息结构， 这里最重要（其实是唯一实用）的就是概念结构设计** **，也就是要画一个E-R图****出来， E：Entity（实体），R：Relationship（关系），这两个对应的关系图 首先理解什么是实体(Entity)： 实体可以是具体的人或事物，也可以看作是一个概念。比如说”安妮“就是一个具体实体，”lol英雄“是一个概念实体。 每个实体都会有很多的属性（attribute），属性就是实体所具有的特性，一个实体可以用若干属性来刻画，比如lol英雄实体可以由名称、别称、性别、英雄定位、生命值、法力值等属性组合，这时属性集合（九尾狐妖，阿狸，女，法师，526，418）代表了这一个阿狸这一个lol英雄。 可以唯一标识的属性集合叫做码（key），唯一标识的意思呢就是说能让人准确认出来知道是哪个，一定要是唯一标识，举个例子，”名称“可以作为lol英雄实体的码，但是如果是HDU全体学生，就不能用姓名作为码，因为你认识的张三和我认识的张三可能根本不是一个人，只是重名而已，这时候就需要学号作为学生实体的码。 这里还有两个拓展的概念，实体型（entity type），就是实体名+属性名集合，例如：lol英雄（名称、性别、英雄定位、生命值、法力值）；而****实体集（entity set）****是指同一类型实体的集合，例如全体英雄。 什么是联系（relationship) 可以先理解现实世界中各个实体之间存在的关系 实体之间的联系可以是一对一（比如正常情况的男女朋友交往），一对多（比如说lol账号和账号下拥有的lol英雄），多对多（比如玩家和游戏） 在抽象现实世界概念模型的时候通常用来标识实体关系， E-R图表示了实体型（矩形）、属性（椭圆）和联系（菱形）， 再看下面这个栗子就明白了 关系模型 首先理解数据模型的概念，所谓数据模型是数据库的核心和基础，是用来描述数据、组织数据和用来对数据进行操作的模型。数据模型所描述的内容包括三个部分：数据结构、数据操作、数据约束。 关系模型是数据模型的一种。 数据库常见的数据模型还有层次模型（树形结构）、网状模型等，这两种已经基本被淘汰不多做介绍。 所谓关系数据库就是采用关系模型作为数据组织方式的数据库系统。 到底要怎么理解关系模型呢？ 简单来说就是：用表格就完事！ 没错，关系模式的数据结构只包含单一的数据结构——关系，在用户看来关系模式数据的逻辑结构是一张扁平的二维表。关系模型是建立在集合代数基础上的 以下是关系模型涉及到的一些术语： 关系（relation） ​ - 一个关系对应通常说的一张表 属性（attribute） ​ - 表中的一列，列名就是属性名 ​ - 相关的概念有主属性、非主属性 元组（tuple） ​ - 表的某一行（即数据库中的每条记录），可以描述一个具体的事物 码 （key） ​ - 候选码： ​ 如果一个属性组的值能唯一标识元组，其子集不能 ​ - 主码 域（domain） ​ - 属性的取值范围来自某个域，比如性别的域一般来说就是（男，女） 分量：元组中的一个属性值 A 关系数据结构 B 关系操作集合 基本关系操作包括查询和增删改 1）查询操作 基于关系代数查询操作分 传统关系运算 并（union） 差（excpet） 交（intersection） 笛卡尔积（cartesian product） 专门的关系运算 选择（select） ​ - 就是限制，针对元组，行运算 投影（projection） ​ - 选择若干属性列组成新关系，列运算 连接（jion） ​ - 从两个关系的笛卡尔积+选择 除运算（division） ​ - 这是一个难点 2）增删改操作 关系操作涉及到的关系数据库标准语言SQL会下一篇博客详细介绍。 C 数据完整性约束 数据完整性就是指数据的正确性和相容性（符合逻辑），又分为实体完整性、参照完整性、用户自定义完整性 实体完整性： 主码唯一且不为空 参照完整性： 不允许引用不存在的实体。参照表插入某条记录，这条记录的外码在被参照表中必须存在 用户自定义完整性： 由用户自定义的数据约束。比如性别只能用男、女表示，人的年龄在0-120之间。常见的用户自定义完整性有NOT NULL，UNIQUE，CHECK等 #关系数据理论 关于规范化 这块是数据库的难点和也是重点，比较抽象，那就直接上个栗子理解吧 函数依赖 候选码:可唯一标识某一元组的属性组，属性组中各个属性缺一不可。【t_student】（学号，姓名，学院），姓名可能会重复，所以其中学号可以唯一标识一条记录，学号就是t_student的候选码。那么假设姓名不会重复，那么候选码就有学号和姓名两个。 又比如【t_grade】（学号，课程，成绩），其中一个学生可以有多条成绩记录，所以需要学号和课程号组合才可以唯一标识一条数据库记录，所以学号、课程号就是t_student的一个候选码。 超码：只要一个属性组可以唯一标识一个元组，那么就说这个属性组是超码 【t_student】（学号，姓名，学院），姓名可能会重复，所以（学号）是一个超码同时也是候选码，（学号，姓名）可唯一标识一个元组，所以其也是超码，但不是候选码，因为少了姓名也可以唯一标识。 主属性：候选码中的属性称为主属性。【t_student】（学号，姓名，学院），学号就是主属性 非主属性：不是主属性就是非主属性呗。【t_student】（学号，姓名，学院），姓名、学院就是非主属性 全码：极端情况下表的所有属性组成该表的候选码，则称为全码 主键/主码：primary key，一个表可能有多个，往往选中一个作为主键 外键/外码：foreign key，假设表A的某个属性attr是另一表B中的主码，且A和B有某种联系，则称attr是外码 参照表：外码所在的表 被参照表：外码所引用（foreign key references）的表 数据依赖公理系统 数据库恢复技术 事务的概念 故障种类 恢复技术 数据转储 登录日志 数据库并发控制 封锁 封锁协议 并发控制 暂且就是以上，持续更新中 (●'◡'●)/ ","link":"https://Viviairy.github.io/ji-chu-shu-ju-ku-yuan-li-gai-shu/"},{"title":"理论基础 | 密码学重点梳理","content":" 密码学是研究编制密码和破译密码技术的科学，包括 密码编码学 (Cryptography) ：研究怎样编码、 如何对消息进行加密 密码分析学(Cryptanalyst)：研究如何对密文进行破译 密码技术相关概念如下： 明文：信息的原始形式 密文：明文经过变换加密后的形式 加密: 由明文——&gt;加密算法——&gt;变成密文的过程 解密: 由密文——&gt;解密算法——&gt;恢复成明文的过程 一、 古典密码 古典密码的基本手段是替代和置换，针对的是字符； 1.1 替换密码 单表代换密码：例如 (Caesar)凯撒密码 结构过于简单，可利用频率分析法进行有效的攻击 多表替换密码：例如 维吉尼亚密码、 Enigma转轮密码机 1.2 置换密码 例如 Hill密码(矩阵加密) 手工阶段和机械阶段使用的密码技术可以称为古典密码技术，古典密码中数据的安全基于加密算法的保密 1949年~1975年，计算机的出现使基于复杂计算的密码成为可能，现代数学方法为加密技术提供了新的工具，信息论为密码学提供了理论基础；主要特点是：(1) 数据的安全基于密钥而不是算法的保密，(2)高次迭代技术和非线性技术的使用，(3) 算法设计需要抵抗各类已知的分析攻击方法 1977年，美国的数据加密标准DES公布，公钥密码使无密钥传输的保密通信成为可能；2001年，美国正式颁布AES为新的国家标准； 近年来，量子密码、DNA密码、化学密码的研究又把我们带入了一个新的密码时代； 二、对称加密 2.1 对称加密体制 对称加密体系也称私钥加密体制、单钥加密体制 特点：加密密钥 = 解密密钥；加密算法 ≈ 解密算法； 优点：速度快，效率高 缺陷：需要安全分配对称密钥 2.2 流密码 对一次一密的模拟，核心是密钥流生成器 经典的密钥流生成器：线性反馈移位寄存器(LFSR) 常见流密码：例如RC4 2.3 分组密码 分组密码设计原则：混淆和扩散 和流密码的区别：对明文的处理方式不同 常见分组密码有： DES(数据加密标准), 3DES ，AES(高级加密标准)，SM4/SMS4(4号国密算法) 2.3.1【 DES 】 DES加密算法与解密算法相同，只是解密使用子密钥与加密子密钥的使用顺序刚好相反 D ES在对明文进行初始置换之后，执行16论的迭代密码。最后经的逆变换得到密文。所谓迭代密码是在密钥控制下多次利用轮函数进行加密变换，以实现扩散和混淆的效果 算法详情： 分组长度：明文、密文64bit 密钥长度：64bit(实际只有56bit) 密钥扩展：输入64位密钥，扩展成都是48bit的轮密钥K1, K2,…,K16 轮变换：每一轮核心运算，输入右分组(32位), 轮密钥(48位)，输出32位；8个S盒，输入6bit，输出4bit 加密：输入明文64位，经过IP置换，对置换后的数据分成左右两半L0与R0，实施16轮轮变换，经过IP-1置换，得到64bit密文 解密与加密几乎一样, 不同之处在于轮密钥的使用顺序 2.3.2 【 3DES 】 分组长度：明文、密文64bit 密钥长度：192bit(实际只有168bit), 使用顺序为(K1, K2, K3) 密文：C=DESk3(DESK2-1(DESK1(M))) 2.3.3 【 AES】 算法名称：Rijndael 分组长度：明/密文128/192/256bit 密钥长度：128/192/256bit 密钥扩展(以128bit为例)：输入密钥128bit，生成11轮128bit的轮密钥 轮变换：对状态矩阵State进行10轮变换，每轮变换包含(1) 字节替换：S盒为8bit输入, 8bit输出；(2) 行移位；(3) 列混合；(4）轮密钥加 加解密：输入明文128bit，作为第0轮的状态矩阵State；经过10轮变换，输出密文128bit 2.3.4【 SM4 国密算法】 前身是SMS4算法 分组长度/密钥长度：128bit 密钥扩展：输入128bit密钥，扩展成32轮32bit的子密钥 加解密：输入明文128位，分成四部分, 实施32次轮变换, 再进行逆序处理得到密文 三、 公钥密码： 3.1 公钥加密体制 也称非对称加密体制、双钥加密体制 特点：加密密钥(公开) ≠ 解密密钥(保密)；加密算法 ≠ 解密算法，公钥密码体系中将密钥一分为二，一个是可公开的密钥PK，另一个则是需要保密的私钥SK ，并且PK≠SK 当多个用户存在时，它可以实现一个用户公钥加密的消息只能被用户私钥解密（可用于公共网络中实现保密通信），或反过来，由一个用户用私钥加密的消息可被多个用户用公钥解读（可用于认证系统中对消息进行数字签） 安全性主要基于数学上的计算困难问题，如大数分解、离散对数、椭圆曲线上离散对数 缺陷：与对称密码相比,效率低 实际应用中常常采用混合加密体制：用 对称加密体制加密明文数据；用公钥加密体制加密对称加密体制中的密钥；解决了对称加密中的密钥分配问题。而由于密钥一般都比较短，用公钥加密也不会多花很长时间 3.1.1【RSA】 安全性基于数论和计算复杂性理论中的大数分解问题，求两个大素数的乘积是计算上容易的，但要分解两个大素数的积求出它的素因子是计算上困难的。 处于安全性考虑，建议使用1024位的模数n，对于重要场合应该使用2048甚至4096位 算法详情： 密钥生成：生成公共参数N，配对的公钥e和私钥d 选取两个n比特的素数p、q，令N = p·q，计算 φ(N)=(p-1)(q-1)，选取与φ(N)互素的正整数e，求正整数d，使得ed ≡ 1 (modφ(N))，公共参数是N, 公钥是e, 私钥是d； 加密： 明文m利用公共参数N和公钥e，加密生成密文c=me(modN) 解密：密文c利用公共参数N和私钥d，解密成明文m'=cd(modN) 3.1.2【Elgamal】 基于离散对数问题 -传送门:Elgamal加密算法详解 3.1.2【ECC】 基于椭圆曲线上离散对数 传送门：ECC椭圆曲线加解密原理详解 3.2 数字签名 消息 — 私钥签名算法 — (消息||签名) — 公钥验证算法 — Yes or No 常见的数字签名体制：RSA数字签名体制、Elgamal数字签名体制、DSA数字签名体制 数字签名：消息 - &gt; (消息, 签名) -&gt; Yes or No 公钥加密：明文 - &gt; 密文 -&gt; 明文 数字签名：签名时用私钥, 验证时用公钥 公钥加密：加密时用公钥, 解密时用私钥 四、 密钥管理 对称密钥管理：多层密钥体系：主密钥 / 次主密钥 / 会话密钥 Diffie-Hellman密钥协商(基于离散对数问题) 公钥数字证书与PKI 公钥基础设施(PKI)：组成部分 数字证书(X.509)：基本格式 核心思想：实现用户身份与其公钥的一一对应 核心机构：认证机构CA 数字证书机制 数字证书 + 公钥加密 数字证书 + 数字签名 五、 Hash函数 Hash函数应用：1. 网站安全登录 ；2. 检测文件篡改 Hash函数基本概念： 定义：任意长度消息-&gt;固定长度的消息摘要 单向性：找原像是困难的 弱抗碰撞性：找第二原像是困难的 强抗碰撞性：找碰撞是困难的 常见Hash函数：MD5、SHA-1 5.1【 MD5 】 消息分组长度：512bit 输出长度：128bit 消息预处理：填充，附加消息长度值 MD5压缩函数：HMD5：{0,1}128+512 —&gt; {0,1}128 MD5主循环：轮数 = 处理后的消息分组数 5.2【 SHA-1 】 消息分组长度：512bit 输出长度：160bit 消息预处理：填充，附加消息长度值 HSHA-1：{0,1}160+512 —&gt; {0,1}160 MD5主循环：轮数 = 处理后的消息分组数 5.3 生日攻击 设Hash函数值为n比特 若取 k = 2n + 1，则肯定能找到碰撞 随机选取不同的消息，则只需要 k ≈ 2n/2，就能以超过50%的概率找到碰撞 2n/2 相比2n小了很多，这种攻击方式称为生日攻击 ","link":"https://Viviairy.github.io/mi-ma-xue-chong-dian-shu-li/"}]}